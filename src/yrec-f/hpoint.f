C
C
C$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
C HPOINT
C$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
      SUBROUTINE HPOINT(M,HSTOT,HS,HS1,HS2,HT,HP,HR,LC,
     *HL,HD,HCOMP,PS,RS,ESTORE,ISTORE,LRESET,JXBEG,MODEL,
     *LSHELL,JCORE,JENV,OMEGA,ETA2,R0,HI,HJM,HKEROT,SJTOT,SKEROT,
C      * BL,DELTS,FP,FT,HG,QIW,SMASS,TEFFL)  ! KC 2025-05-31
     * FP,FT,HG,QIW,TEFFL)

      PARAMETER(JSON=5000)
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT LOGICAL*4(L)

C MHP 10/02 ADDED MRZONE,MXZONE TO DIMENSION STATEMENTS
      DIMENSION HS(JSON),HS1(JSON),HS2(JSON),HT(JSON),
     * OMEGAL(JSON),HPMAX(4),NFLAG(100),HP(JSON),
     * HR(JSON),HL(JSON),HD(JSON),HCOMP(15,JSON),LCZ(JSON),FTX(JSON),
     * OMEGA(JSON),ETA2(JSON),R0(JSON),HI(JSON),HJM(JSON),
     * HKEROT(JSON),FP(JSON),FT(JSON),HG(JSON),LC(JSON),QIW(JSON),
     * FPX(JSON),
     * MRZONE(13,2),MXZONE(12,2)
      DIMENSION PS(3),RS(3),ESTORE(4)
      COMMON/LUOUT/ILAST,IDEBUG,ITRACK,ISHORT,IMILNE,IMODPT,ISTOR,IOWR
      COMMON/BURN/HCOMPM(15,JSON)
      COMMON/CCOUT/LSTORE,LSTATM,LSTENV,LSTMOD,LSTPHYS,LSTROT,LSCRIB,LSTCH,LPHHD
      COMMON/CCOUT1/NPENV,NPRTMOD,NPRTPT,NPOINT
      COMMON/CCOUT2/LDEBUG,LCORR,LMILNE,LTRACK,LSTPCH
      COMMON/COMP/XENV,ZENV,ZENVM,AMUENV,FXENV(12),XNEW,ZNEW,STOTAL,
     *     SENV
      COMMON/CONST1/ CLN,CLNI,C4PI,C4PIL,C4PI3L,CC13,CC23,CPI
      COMMON/CONST3/CDELRL,CMIXL,CMIXL2,CMIXL3,CLNDP,CSECYR
      COMMON/CTLIM/ATIME(14),TCUT(5),TSCUT,TENV0,TENV1,TENV,TGCUT
      COMMON/CTOL/HTOLER(5,2),FCORR0,FCORRI,FCORR,HPTTOL(12),NITER1,
     *     NITER2,NITER3
      COMMON/DPMIX/DPENV,ALPHAC,ALPHAE,ALPHAM,BETAC,IOV1,IOV2,
     *      IOVIM, LOVSTC, LOVSTE, LOVSTM, LSEMIC, LADOV, LOVMAX
      COMMON/DWMAX/QWRMAX(JSON),QWRMX0(JSON)
      COMMON/FLAG/LEXCOM
      COMMON/OLDMOD/HPO(JSON),HTO(JSON),HRO(JSON),HLO(JSON),
     *     HDO(JSON),HCOMPP(15,JSON),HSS(JSON),LCO(JSON),LCZO(JSON),TEFFLO,MO
      COMMON/OLDROT/WOLD(JSON),HJX(JSON),HIO(JSON),HGO(JSON),
     *     R0X(JSON),ETA2X(JSON)
      COMMON/OLDPHY/DELO(JSON),DELAO(JSON),AMUO(JSON),OO(JSON),
     *     CPO(JSON),QDTO(JSON),VELO(JSON),VISCO(JSON),
     *     THDIFO(JSON),ESUMO(JSON),DELRO(JSON),EPSO(JSON)
C MHP 06/02
C Time change of theta
      COMMON/OLDROT2/THO(JSON),THN(JSON),THM(JSON),
     *               DDELM(JSON),FESTIME(JSON),THP(JSON),
     *               QWRST(JSON),WMST(JSON),QWRMST(JSON)
      COMMON/CONST2/CGAS,CA3,CA3L,CSIG,CSIGL,CGL,CMKH,CMKHN
      COMMON/OPTAB/OPTOL,ZSI,IDT,IDD(4)
      COMMON/ROT/WNEW,WALPCZ,ACFPFT,ITFP1,ITFP2,LROT,LINSTB,LWNEW
      COMMON/SCRTCH/SESUM(JSON),SEG(7,JSON),SBETA(JSON),SETA(JSON),
     * LOCONS(JSON),SO(JSON),SDEL(3,JSON),SFXION(3,JSON),SVEL(JSON),SCP(JSON)
      COMMON/TEMP/CP(JSON),HAMU(JSON),SQDT(JSON),THDIF(JSON),
     *     VISC(JSON)
C 7/91 ENTROPY TERM COMMON BLOCK ADDED.
      COMMON/ENTROP/HTT0(JSON),HPP0(JSON),HLL0(JSON),HRR0(JSON)
C MHP 05/02 DEUTERIUM BURNING RATE ADDED
      COMMON/DEUTER/DRATE(JSON),DRATE0(JSON),FMASSACC,JCZ
      DIMENSION ID(7)
      DIMENSION HFO(JSON),HKO(JSON)
C MHP 6/00 ADDED DUMMY VECTOR
C MHP 7/02 ADDED CHI VECTOR - A RUNNING TOTAL OF THE NORMALIZED
C DIFFERENCES IN M, L, P BETWEEN SHELLS THAT IS USED TO SET THE
C POINT SPACING.
      DIMENSION XTAB(JSON),YTAB(JSON),CHI(JSON),Y2(JSON)
      DIMENSION IXFLAG(JSON)
C       DATA IDMAX/JSON/
      DATA ID/1,2,4,5,6,7,9/
      SAVE

C  THIS SUBROUTINE REZONES THE MODEL, SPACING THE SHELLS SUCH THAT
C  THE MAXIMUM DISTANCE BETWEEN 2 SUCCESSIVE POINTS IN P,L,X, AND Z
C  SPECIFIED BY THE USER IS NOT EXCEEDED.  IT ALSO FLAGS REAL
C  DISCONTINUITIES TO PREVENT ARTIFICIAL SMOOTHING.
      LRESET = .FALSE.
C  IEND IS THE NUMBER OF SPECIES THE PROGRAM IS KEEPING TRACK OF
      IEND = 11
      IF(LEXCOM) IEND = 15
C CHECK IF TEMPERATURE OF OUTERMOST HENYEY POINT > MIMIMUM ENVELOPE T
      IF(HT(M).LT.TENV0) THEN
       DO 20 I = M-1,1,-1
          IF(HT(I).GT.TENV0) THEN
             WRITE(ISHORT,10) M,I
   10     FORMAT(' OUTER POINTS DELETED OLD M =',I5,'  NEW M =',I5)
             M = I
             SENV = HS(M) - HSTOT
             LRESET = .TRUE.
             GOTO 40
          ENDIF
   20    CONTINUE
C  ENTIRE MODEL HAS T<TENV0 - UNLIKELY - BUT STOP IF TRUE
       WRITE(ISHORT,30)
       WRITE(IOWR,30)
   30    FORMAT(1X,39('>'),40('<')/1X,'ERROR IN HPOINT'/
     *   1X,'MAX. STAR T LESS THAN MINIMUM ENVELOPE T.RUN STOPPED')
       STOP
   40    CONTINUE
C  CHECK IF OUTER POINT T < MAXIMUM ENVELOPE T
      ELSE IF(HT(M).GT.TENV1.AND.ISTORE.NE.0) THEN
       M = M + 1
       SENV = ESTORE(4)
       HS(M) = HSTOT + SENV
       HP(M) = HP(M-1) + (ESTORE(1) - PS(ISTORE))
       HT(M) = HT(M-1) + (ESTORE(1) - PS(ISTORE))*0.250D0
       HR(M) = HR(M-1) + (ESTORE(3) - RS(ISTORE))
       HL(M) = HL(M-1)
       DO 50 I = 1,IEND
          HCOMP(I,M) = HCOMP(I,M-1)
   50    CONTINUE
       HD(M) = HP(M) - HT(M) - 8.0D0
       J = M - 1
       WRITE(ISHORT,60) J,HS(J),HP(J),HT(J),HR(J),M,HS(M),HP(M),
     *   HT(M),HR(M)
   60    FORMAT(' OUTER POINT ADDED',I5,F15.10,'  PTR',3F10.6)
       LRESET = .TRUE.
      ENDIF


C SET UP FLAGGED POINTS - PROGRAM WILL NOT REZONE ACROSS FLAGGED POINTS
      IFLAG = 1
C FLAG EDGES OF CENTRAL AND SURFACE CONVECTION ZONES
      IF(JCORE.GT.1) THEN
       NFLAG(IFLAG) = JCORE
       IFLAG = IFLAG + 1
      ENDIF
      IF(JENV.LT.M .AND.JENV.GT.1) THEN
       NFLAG(IFLAG) = JENV
       IFLAG = IFLAG + 1
      ENDIF
C FLAG EDGE OF H SHELL
      IF(LSHELL.AND.JXBEG.GT.1) THEN
       NFLAG(IFLAG) = JXBEG - 1
       IFLAG = IFLAG + 1
      ENDIF
      DO 120 I = 2,M
C  TEST FOR FLAGGING DUE TO X GRADIENT
       IF(DABS(HCOMP(1,I)-HCOMP(1,I-1)).GT.HPTTOL(3)) THEN
          NFLAG(IFLAG) = I
          IFLAG = IFLAG + 1
C  TEST FOR FLAGGING DUE TO Z GRADIENT
       ELSE IF(DABS(HCOMP(3,I)-HCOMP(3,I-1)).GT.HPTTOL(4)) THEN
          NFLAG(IFLAG) = I
          IFLAG = IFLAG + 1
C  TEST FOR FLAGGING DUE TO GRADIENT IN LOG OMEGA.
       ELSE IF(LROT) THEN
          WLTOP = DLOG10(OMEGA(I))
          WLBOT = DLOG10(OMEGA(I-1))
          IF(DABS(WLTOP-WLBOT).GT.HPTTOL(12)) THEN
             NFLAG(IFLAG) = I
             IFLAG = IFLAG + 1
          ENDIF
       ENDIF
       IF(IFLAG.GE.100) THEN
          WRITE(ISHORT,110)
  110       FORMAT(1X,'MORE THAN 100 FLAG POINTS-FIRST 100 RETAINED')
          GOTO 130
       ENDIF
  120 CONTINUE
C  PMAX1 = MAX DEL LOG P BELOW SURFACE C.Z. AND BELOW FINELY ZONED
C  REGION AROUND IT.
C  PMAX2 = MAX DEL LOG P BETWEEN LOWER EDGE OF FINELY ZONED REGION
C  AROUND SURFACE C.Z. AND BASE OF OVERSHOOT REGION.
C  PMAX3 = SAME FOR OVERSHOOT REGION.
C  PMAX4 = MAX DEL LOG P ABOVE BASE OF SURFACE C.Z. IN FINELY ZONED
C  REGION AROUND IT.
C  PMAX5 = SAME FOR THE OUTER POINTS IN THE STAR.
      PMAX1 = HPTTOL(11)
      PMAX4 = HPTTOL(10)
      PMAX5 = HPTTOL(8)
      IF(.NOT.LC(M))THEN
       JOS = M
       JFINE = M
      ELSE IF (JENV.EQ.1)THEN
       JOS = 1
       JFINE = 1
      ELSE
C  LOCATE BASE OF OVERSHOOT REGION IF APPLICABLE.
       IF(.NOT.LOVSTE)THEN
          I = JENV
          JOS = JENV
       ELSE
          DO 191 JOS = JENV-1,1,-1
             IF(HP(JOS)-HP(JENV).GT.ALPHAE)GOTO 193
  191       CONTINUE
  193       JOS = JOS + 1
          DELP = HP(JOS)-HP(JENV)
          IF(DELP.GT.0.0D0) THEN
             NP = INT(DELP/HPTTOL(10))
             IF(MOD(DELP,HPTTOL(10)).NE.0D0)NP=NP+1
             PMAX3 = DELP/DFLOAT(NP)
          ELSE
             PMAX3 = HPTTOL(10)
          ENDIF
            IF(JOS.GT.1)THEN
               NFLAG(IFLAG) = JOS
               IFLAG = IFLAG + 1
            ENDIF
       ENDIF
       IF(HPTTOL(7).EQ.0.0D0) THEN
          JFINE = JOS
       ELSE
C  NOW LOCATE BASE OF FINELY ZONED REGION.
          IF(JOS.EQ.1)THEN
             JFINE = 1
             GOTO 198
          ENDIF
          DO 195 JFINE = JOS-1,1,-1
             IF(HP(JFINE) - HP(JENV).GT.HPTTOL(7))GOTO 197
  195       CONTINUE
  197       JFINE = JFINE + 1
          IF(JFINE.EQ.JOS)GOTO 198
          DELP = HP(JFINE) - HP(JOS)
          NP = INT(DELP/HPTTOL(10))
          IF(MOD(DELP,HPTTOL(10)).NE.0D0)NP=NP+1
          PMAX2 = DELP/DFLOAT(NP)
          IF(PMAX2.EQ.0.0D0)PMAX2 = HPTTOL(10)
            IF(JFINE.GT.1)THEN
               NFLAG(IFLAG) = JFINE
               IFLAG = IFLAG + 1
            ENDIF
  198       CONTINUE
       ENDIF
      ENDIF
  130 NFLAG(IFLAG) = M
C ARRANGE THE FLAG POINTS IN ASCENDING ORDER
      IF(IFLAG.EQ.1) GOTO 180
  140 CONTINUE
      LDONE = .TRUE.
      DO 150 I = 1,IFLAG-1
       IF (NFLAG(I+1).LT.NFLAG(I)) THEN
          NTEMP = NFLAG(I)
          NFLAG(I) = NFLAG(I+1)
          NFLAG(I+1) = NTEMP
          LDONE = .FALSE.
       ENDIF
  150 CONTINUE
      IF(.NOT.LDONE) GOTO 140
C ENSURE THAT POINTS ARENT FLAGGED MORE THAN ONCE.
      I = 2
  160 CONTINUE
      IF(NFLAG(I).EQ.NFLAG(I-1))THEN
       IF(I.LT.IFLAG) THEN
          DO 170 J = I,IFLAG-1
             NFLAG(J) = NFLAG(J+1)
  170       CONTINUE
       ENDIF
       IFLAG = IFLAG - 1
      ENDIF
      I = I + 1
      IF(I.LE.IFLAG) GOTO 160
  180 CONTINUE
      WRITE(ISHORT,185) (NFLAG(J),J=1,IFLAG)
  185 FORMAT(1X,'FLAG-POINTS',20I4)
C BEGIN REFLOATING OF POINTS
      IF(LROT) THEN
       DO 190 I = 1,M
          IF(OMEGA(I).GT.0.0D0) THEN
             OMEGAL(I) = DLOG10(OMEGA(I))
          ELSE
             OMEGAL(I) = 0.0D0
          ENDIF
  190    CONTINUE
      ENDIF
      HSS(1) = HS(1)
      HPO(1) = HP(1)
      HLO(1) = HL(1)
      HKO(1) = HCOMP(1,1)
      HFO(1) = HCOMP(3,1)
      HLMAX = HL(M)
C JVS 04/14 added Teff to saved variables
        TEFFLO = TEFFL
C  JVS 05/25 Added model number to list of saved values
      MO = M
      DO I = M-1,1,-1
         IF(HL(I).GT.HLMAX)THEN
            HLMAX = HL(I)
         ENDIF
      END DO
      HPMAX(1) = HPTTOL(8)
      HPMAX(2) = HPTTOL(9)*HLMAX
      HPMAX(3) = HPTTOL(5)
      HPMAX(4) = HPTTOL(6)
C      KFACT = 0
C  200 CONTINUE
      IIFLG = 1
      J = 2
      I0 = 2
C CHI IS THE NORMALIZED VECTOR OF DIFFERENCES IN M,L,P:
C CHI = HS/DELTA M + HL/DELTA L - HP/DELTA P
      DM = HPTTOL(2)
      DL = HPMAX(2)
      CHI(1) = 1.0D0
      DO J = 2, M
         TESTP = HP(J) - HP(JENV)
         IF(ABS(TESTP).LT.HPTTOL(7))THEN
C FINELY ZONED REGION
            DP = HPTTOL(10)
         ELSE IF(TESTP.GT.HPTTOL(7))THEN
C BELOW SURFACE CZ
            DP = HPTTOL(11)
         ELSE
C IN SURFACE CZ
            DP = HPTTOL(8)
         ENDIF
         IF(HL(J).GT.HL(J-1))THEN
            DCHI = (HS(J)-HS(J-1))/DM +
     *             (HL(J)-HL(J-1))/DL -
     *             (HP(J)-HP(J-1))/DP
         ELSE
            DCHI = (HS(J)-HS(J-1))/DM -
     *             (HP(J)-HP(J-1))/DP
         ENDIF
         CHI(J) = CHI(J-1)+DCHI
      END DO
      DO J = 1,M
         XTAB(J) = CHI(J)
         YTAB(J) = HS(J)
      END DO
C GET SPLINE COEFFICIENTS
      CALL SPLINC(XTAB,YTAB,Y2,M)
      CHIPREV = CHI(1)
      JPREV = 1
      MNEW = 1
      DO I = 1,IFLAG
         DELCHI = CHI(NFLAG(I))-CHIPREV
         NPT = INT(DELCHI)+1
         IF(MNEW+NPT.GT.JSON)THEN
C EXCEEDED ARRAY DIMENSIONS; COMPLAIN AND STOP
            WRITE(*,101)MNEW+NPT,JSON
 101        FORMAT(' DESIRED NUMBER OF POINTS ',I6,'EXCEEEDS JSON ',
     *             I6/' RUN STOPPED')
            STOP 9999
         ENDIF
         DCHI = DELCHI/DFLOAT(NPT)
C ASSIGN NEW POINTS
         DO J = JPREV+1,JPREV+NPT
            X = CHIPREV + DCHI
            CALL SPLINTD2(XTAB, YTAB, M, Y2, X, Y, KLO, KHI)
            HSS(J) = Y
            CHIPREV = X
C

         END DO
         MNEW = MNEW + NPT
         JPREV = MNEW
C
      END DO







C TEST FOR ASSIGNING POINTS BASED ON THE GRADIENT IN X.
      DO J = 1,M
         XTAB(J) = HS(J)
         YTAB(J) = HCOMP(1,J)
      END DO
C GET SPLINE COEFFICIENTS
      CALL SPLINC(XTAB,YTAB,Y2,M)
C ASSIGN INTERPOLATED VECTOR OF X VALUES TO HIO
      DO I = 2,MNEW
         X = HSS(I)
         CALL SPLINTD2(XTAB, YTAB, M, Y2, X, Y, KLO, KHI)
         HKO(I) = Y
      END DO




C SKIP IF HPMAX(3) IS ZEROED OUT
      IF(HPMAX(3).LE.1.0D-15)GOTO 102
C TEST ON X-CHANGE (ONLY FOR INCREASING X) USING HIO AS DUMMY ARRAY
      IXX = 0
      DO J = MNEW,2,-1
         IF(HKO(J)-HKO(J-1).GT.HPMAX(3)) THEN
            IXX = IXX + 1
            IXFLAG(IXX) = J
         ENDIF
      END DO
      IF(IXX.EQ.0)GOTO 102
      MM = MNEW
      DO I = 1,IXX
         J = IXFLAG(I)
         DX = (HKO(J) - HKO(J-1))/HPMAX(3)
C NUMBER OF NEW POINTS NEEDED
         NN = INT(DX)
C
         DSS = (HSS(J)-HSS(J-1))/DFLOAT(NN+1)
         DO K = MM+NN,J+NN,-1
            HSS(K) = HSS(K-NN)
C
         END DO
         DO K = J + NN -1, J -1, -1
            HSS(K) = HSS(K+1) - DSS
         END DO
         MM = MM + NN
      END DO
      MNEW = MM
C
 102  CONTINUE
C TEST FOR ASSIGNING POINTS BASED ON THE GRADIENT IN Z.
      DO J = 1,M
         XTAB(J) = HS(J)
         YTAB(J) = HCOMP(3,J)
      END DO
C GET SPLINE COEFFICIENTS
      CALL SPLINC(XTAB,YTAB,Y2,M)
C ASSIGN INTERPOLATED VECTOR OF Z VALUES TO HGO
      DO I = 2,MNEW
         X = HSS(I)
         CALL SPLINTD2(XTAB, YTAB, M, Y2, X, Y, KLO, KHI)
         HFO(I) = Y
C
      END DO
C TEST ON Z-CHANGE (ONLY FOR DECREASING Z) USING HIO AS DUMMY ARRAY
C SKIP IF HPMAX(4) IS ZEROED OUT
C

      IF(HPMAX(4).LE.1.0D-15)GOTO 103
      IXX = 0
      DO J = MNEW,2,-1
         IF(HFO(J-1)-HFO(J).GT.HPMAX(4)) THEN
            IXX = IXX + 1
            IXFLAG(IXX) = J
        ENDIF
      END DO
C
      IF(IXX.EQ.0)GOTO 103
      MM = MNEW
C
      DO I = 1,IXX
         J = IXFLAG(I)
         DZ = (HFO(J-1) - HFO(J))/HPMAX(4)
C NUMBER OF NEW POINTS NEEDED
         NN = INT(DZ)
         DSS = (HSS(J)-HSS(J-1))/DFLOAT(NN+1)
         DO K = MM+NN,J+NN,-1
            HSS(K) = HSS(K-NN)
         END DO
         DO K = J + NN -1, J -1, -1
            HSS(K) = HSS(K+1) - DSS
         END DO
         MM = MM + NN
      END DO
      MNEW = MM
C
 103  CONTINUE
C DELETE NEW POINTS THAT ARE TOO CLOSE TOGETHER.
C (NOTE HDO IS BEING USED AS A DUMMY ARRAY HERE).
      J = 1
      HDO(J) = HSS(J)
      DO 810 JJ = 2,MNEW-1
C
       IF(HSS(JJ) - HDO(J).GT.HPTTOL(1))THEN
          J = J + 1
          HDO(J) = HSS(JJ)
       ENDIF
  810 CONTINUE
      J = J + 1
      HDO(J) = HSS(MNEW)
      MNEW = J
      DO 820 J = 2,MNEW
       HSS(J) = HDO(J)
  820 CONTINUE
C

C  NOW LOCATE OUTER EDGE OF CONVECTIVE CORE AND INNER EDGE OF CONVECTIVE
C  ENVELOPE IN THE NEW POINT DISTRIBUTION.
      IF(JCORE.GT.1)THEN
       DO 823 J = 2,MNEW
          IF(HSS(J).GT.HS(JCORE))GOTO 824
  823    CONTINUE
  824    JCORE = J - 1
      ELSE
       JCORE = 1
      ENDIF
      IF(JENV.LT.M)THEN
       DO 825 J = MNEW-1,1,-1
          IF(HSS(J).LT.HS(JENV))GOTO 826
  825    CONTINUE
  826    JENV = J + 1
      ELSE
       JENV = MNEW
      ENDIF
      IF(JCORE.GT.1)THEN
       DO 827 I = 1,JCORE
          LC(I) = .TRUE.
  827    CONTINUE
       JBEG = JCORE + 1
      ELSE
       JBEG = 1
      ENDIF
      IF(JENV.LT.MNEW)THEN
       DO 828 I = JENV,MNEW
          LC(I) = .TRUE.
  828    CONTINUE
       JEND = JENV - 1
      ELSE
       JEND = MNEW
      ENDIF
      IF(JEND.LT.1.OR.JBEG.GT.MNEW) GOTO 830
      DO 829 J = JBEG,JEND
       LC(J) = .FALSE.
  829 CONTINUE
  830 CONTINUE


C  NOW USE AN OSCILLATORY SPLINE TO FIT THE OLD RUN OF PHYSICAL VARIABLES
C  AT THE NEW RUN OF MASS POINTS.
      NTAB = M
      NTOT = MNEW
C  XVAL=RUN OF NEW MODEL MASS COORDINATES(HSS)
C  XTAB = RUN OF OLD MODEL MASS CO-ORDINATES(HS)
C  YTAB = RUN OF VARIABLE WHOSE VALUE AT THE NEW MASS POINTS
C         IS DESIRED(HP,HT,HL,HR,HD,ETC.)
C  NTAB = NUMBER OF DATA POINTS(M)
C  NTOT=NUMBER OF POINTS AT WHICH SPLINE IS TO BE EVALUTED(MNEW)
C  YVAL = OUTPUT RUN OF VARIABLE VALUES AT THE NEW RUN OF MASS POINTS.
C  FORM OF CALL IS CALL OSPLIN(XVAL,YVAL,XTAB,YTAB,NTAB,NTOT)
C  DO EACH COMPOSITION IN ORDER USING HPO AND HTO AS DUMMY ARRAYS.
C 7/91 ADD ENTROPY TERM INTERPOLATION.
      DO 904 J = 1,M
         HPO(J) = HTT0(J)
  904 CONTINUE
      CALL OSPLIN(HSS,HTO,HS,HPO,NTAB,NTOT)
      DO 905 J = 1,MNEW
         HTT0(J) = HTO(J)
  905 CONTINUE

C


      DO 906 J = 1,M
         HPO(J) = HPP0(J)
  906 CONTINUE
      CALL OSPLIN(HSS,HTO,HS,HPO,NTAB,NTOT)
      DO 907 J = 1,MNEW
         HPP0(J) = HTO(J)
  907 CONTINUE
      DO 911 J = 1,M
         HPO(J) = HLL0(J)
  911 CONTINUE
      CALL OSPLIN(HSS,HTO,HS,HPO,NTAB,NTOT)
      DO 912 J = 1,MNEW
         HLL0(J) = HTO(J)
  912 CONTINUE
      DO 913 J = 1,M
         HPO(J) = HRR0(J)
  913 CONTINUE
      CALL OSPLIN(HSS,HTO,HS,HPO,NTAB,NTOT)
      DO 914 J = 1,MNEW
         HRR0(J) = HTO(J)
  914 CONTINUE


      DO 850 I = 1,IEND
       DO 833 J = 1,M
          HPO(J) = HCOMP(I,J)
  833    CONTINUE
         CALL OSPLIN(HSS,HTO,HS,HPO,NTAB,NTOT)
       DO 835 J = 1,MNEW
          HCOMP(I,J) = HTO(J)
  835    CONTINUE
C  HCOMPP IS THE ARRAY OF COMPOSITION AT THE BEGINNING OF THE TIMESTEP.
C  THIS IS NEEDED FOR COMPOSITION DIFFUSION IN ROTATING MODELS.
       DO 840 J = 1,M
          HPO(J) = HCOMPP(I,J)
  840    CONTINUE
         CALL OSPLIN(HSS,HTO,HS,HPO,NTAB,NTOT)
       DO 845 J = 1,MNEW
          HCOMPP(I,J) = HTO(J)
  845    CONTINUE
  850 CONTINUE


C  HCOMPM IS THE ARRAY OF CHANGES IN COMPOSITION DUE TO NUCLEAR BURNING.
C  THIS IS NEEDED FOR COMPOSITION DIFFUSION IN ROTATING MODELS.
      DO 849 I = 1,7
       DO 847 J = 1,M
          HPO(J) = HCOMPM(ID(I),J)
  847    CONTINUE
         CALL OSPLIN(HSS,HTO,HS,HPO,NTAB,NTOT)
       DO 848 J = 1,MNEW
          HCOMPM(ID(I),J) = HTO(J)
  848    CONTINUE
  849 CONTINUE
C MHP 05/02 IF THE SURFACE DEUTERIUM IS ABOVE
C THRESHOLD (1.0D-14) FIND THE NEW RUN OF
C DEUTERIUM BURNING RATES
      IF(LEXCOM .AND. HCOMP(12,M).GE.1.0D-14)THEN
         DO J = 1,M
            HPO(J) = DRATE0(J)
         END DO
         CALL OSPLIN(HSS,HTO,HS,HPO,NTAB,NTOT)
         DO J = 1,MNEW
            DRATE0(J) = HTO(J)
         END DO
      ENDIF
C NOW FIND RUN OF P,R,L,T,AND RHO IN THAT ORDER FOR THE NEW POINTS.

      CALL OSPLIN(HSS,HPO,HS,HP,NTAB,NTOT)
      CALL OSPLIN(HSS,HRO,HS,HR,NTAB,NTOT)
      CALL OSPLIN(HSS,HLO,HS,HL,NTAB,NTOT)
      CALL OSPLIN(HSS,HTO,HS,HT,NTAB,NTOT)
      CALL OSPLIN(HSS,HDO,HS,HD,NTAB,NTOT)

C FOR ROTATING MODELS FIND THE NEW RUN OF OMEGA,J/M,FP,FT,R0,AND ETA2.
      IF(LROT) THEN
         CALL OSPLIN(HSS,WOLD,HS,OMEGA,NTAB,NTOT)
         CALL OSPLIN(HSS,HJX,HS,HJM,NTAB,NTOT)
         CALL OSPLIN(HSS,FPX,HS,FP,NTAB,NTOT)
         CALL OSPLIN(HSS,FTX,HS,FT,NTAB,NTOT)
         CALL OSPLIN(HSS,R0X,HS,R0,NTAB,NTOT)
         CALL OSPLIN(HSS,ETA2X,HS,ETA2,NTAB,NTOT)
      ENDIF
C

C     SPIT OUT POINT DISTRIBUTION DETAILS IF REQUESTED
      IF(LDEBUG .AND.  NPOINT.LT.9999) THEN
      IF(MOD(MODEL,NPOINT).EQ.0) THEN
         MINMIN = MIN0(M,MNEW)
C
         WRITE(IDEBUG,910)
  910    FORMAT('1',20X,'OLD POINTS',54X,'NEW POINTS'/2(3X,'N',5X,'S',
     *   8X,'P',7X,'T',7X,'R',8X,'L',7X,'X',4X,'Z',3X,'O16',1X) )
         WRITE(IDEBUG,920) (I,HS(I),HP(I),HT(I),HR(I),HL(I),
     *   HKO(I),HFO(I),HCOMP(9,I),I,HSS(I),HPO(I),HTO(I),
     *   HRO(I),HLO(I),HCOMP(1,I),HCOMP(3,I),HCOMP(9,I), I = 1,MINMIN)
  920    FORMAT( 2(1X,I3,F11.7,F8.4,F8.5,F8.4,1PE9.2,0PF6.3,2F5.3) )
         IF(M.GT.MINMIN) THEN
            MINMIN = MINMIN + 1
            WRITE(IDEBUG,930) (I,HS(I),HP(I),HT(I),HR(I),HL(I),
     *      HKO(I),HFO(I),HCOMP(9,I),I=MINMIN,M)
  930       FORMAT( 1X,I3,F11.7,F8.4,F8.5,F8.4,1PE9.2,0PF6.3,2F5.3)
         ELSE IF(MNEW.GT.MINMIN) THEN
            MINMIN = MINMIN + 1
            WRITE(IDEBUG,940)(I,HSS(I),HPO(I),HTO(I),HRO(I),HLO(I),
     *      HCOMP(1,I),HCOMP(3,I),HCOMP(9,I),I=MINMIN,MNEW)
  940       FORMAT(65X,I3,F11.7,F8.4,F8.5,F8.4,1PE9.2,0PF6.3,2F5.3)
         ENDIF
      ENDIF
      ENDIF


C TRANSFER NEW POINTS.
      DO 1000 J = 1,MNEW
       HS(J) = HSS(J)
       HP(J) = HPO(J)
       HT(J) = HTO(J)
       HR(J) = HRO(J)
       HL(J) = HLO(J)
       HD(J) = HDO(J)
 1000 CONTINUE
      IF (LROT) THEN
       DO 1005 J = 1, MNEW
          HJM(J) = HJX(J)
          OMEGA(J) = WOLD(J)
          FP(J) = FPX(J)
          FT(J) = FTX(J)
          ETA2(J) = ETA2X(J)
          R0(J) = R0X(J)
 1005    CONTINUE
      ENDIF
C MHP 6/00 INTERPOLATED IN ENERGY GENERATION AT START OF TIMESTEP
      IF(LROT .OR. (LEXCOM .AND. LOVSTE))THEN
         CALL OSPLIN(HSS,ESUMO,HS,SESUM,NTAB,NTOT)
         DO IM = 1,M
            YTAB(IM) = SESUM(IM)+SEG(6,IM)+SEG(7,IM)
         END DO
         CALL OSPLIN(HSS,EPSO,HS,YTAB,NTAB,NTOT)
      ENDIF
      WRITE(ISHORT,1020) M,MNEW
 1020 FORMAT(' POINTS  OLD',I5,'   NEW',I5)
      M = MNEW
C SET UP WEIGHTS AND MASSES
      DS3 = DEXP(CLNDP*HS(1))
      DS2 = - DS3
      DO 1030 I = 2,M
       DS1 = DS2
       DS2 = DS3
       DS3 = DEXP(CLNDP*HS(I))
       HS1(I-1) = DS2
       HS2(I-1) = 0.5D0*(DS3-DS1)
 1030 CONTINUE
      HS1(M) = DS3
      HS2(M) = DEXP(CLN*HSTOT) - 0.5D0*(DS2+DS3)
      IF(LROT) THEN
C  FIRST GUESS AT MOMENT OF INERTIA(HI)
       DO 1070 I=1,M
          HI(I) = CC23*HS2(I)*DEXP(CLN*2.0D0*HR(I))
 1070    CONTINUE
C   CALCULATE OVERSHOOT
       CALL OVROT(HCOMP,HD,HP,HR,HS,HT,LC,M,LCZ,MRZONE,MXZONE,
     &        NRZONE,NZONE)
C JNT 2025/09/03 duplicating 2015/04/06 recompute moment of interia
C before recomputing the rotation I am less confident that this is 
C necessary since WALPCZ does run in this version but I don't think
C it can hurt.
       CALL MOMI(ETA2,HR,HS,HS2,1,M,OMEGA,R0,HI,QIW)
C END JNT
     
C   FIND THE ANGULAR VELOCITY OMEGA THAT CORRESPONDS TO THE GIVEN
C   SPECIFIC ANGULAR MOMENTUM HJM.
       CALL GETROT(HD,HJM,HR,HS,HS2,LCZ,M,ETA2,HI,OMEGA,QIW,R0)
C  CALCULATE FP,FT,R0 AND ETA2 GIVEN OMEGA
       CALL FPFT(HD,HR,HS,M,OMEGA,ETA2,FP,FT,HG,R0)
C  FIND CORRECT MOMENT OF INERTIA(HI)
C        CALL MOMI(ETA2,HD,HR,HS,HS2,1,M,OMEGA,R0,HI,QIW,M)  ! KC 2025-05-31
       CALL MOMI(ETA2,HR,HS,HS2,1,M,OMEGA,R0,HI,QIW)
C  FIND NEW TOTAL ANGULAR MOMENTUM
       SUMJ = 0.0D0
       SUMKE = 0.0D0
       DO 1110 I = 1,M
          HJ = HJM(I)*HS2(I)
          HKEROT(I) = 0.5D0*OMEGA(I)*HJ
          SUMJ = SUMJ + HJ
          SUMKE = SUMKE + HKEROT(I)
 1110    CONTINUE
       WRITE(ISHORT,1120)SJTOT,SUMJ,SKEROT,SUMKE
 1120    FORMAT(1X,'TOTAL J OF STAR - PREVIOUS ',1PE21.13,' NEW ',
     *    1PE21.13/' TOTAL ROTATIONAL K.E. OF STAR-PREVIOUS ',1PE21.13,
     *    ' NEW ',1PE21.13)
       SJTOT = SUMJ
       SKEROT = SUMKE
C  STORE THE OLD MODEL STRUCTURE FOR USE IN DIFFUSION.
       DO 1130 I = 1,M
          WOLD(I) = OMEGA(I)
          HGO(I) = HG(I)
          HIO(I) = HI(I)
          ETA2X(I) = ETA2(I)
          R0X(I) = R0(I)
          LCO(I) = LC(I)
          LCZO(I) = LCZ(I)
C MHP 10/91 J/M STORED IN HJX FOR I/O USE.
            HJX(I) = HJM(I)
 1130    CONTINUE
C MHP 9/91 CHANGE : T GRADIENTS STORED IF LEXCOM=T AND LOVSTE=T; OR FOR
C ROTATION; THIS IS NEEDED SO THAT THE BASE OF THE OVERSHOOT REGION FOR
C PRE-MS MODELS CAN BE ACCURATELY LOCATED.
      ENDIF
      IF(LROT .OR. (LEXCOM .AND. LOVSTE))THEN
C END OF 9/91 CHANGE
C   FIND THE NEW RUN OF PHYSICAL VARIABLES AT THE NEW SET OF POINTS;
C   THIS IS NEEDED EVEN IN THE ABSENCE OF DIFFUSION TO ACCURATELY LOCATE
C   THE EDGES OF CONVECTION ZONES.
C        CALL PHYSIC(FP,FT,HCOMP,HD,HG,HL,HP,HR,HS,HT,LC,LCZ,M,TEFFL)  ! KC 2025-05-31
       CALL PHYSIC(FP,FT,HCOMP,HD,HG,HL,HP,HR,HS,HT,LC,M,TEFFL)
C   FOR DIFFUSION STORE THE AUXILLARY QUANTITIES NEEDED TO CALCULATE
C   VELOCITIES AT THE START OF THE TIMESTEP WITH THE NEW POINT DISTRIBUTION
C   SO THAT A SERIES OF SMALL DIFFUSION TIMESTEPS CAN BE TAKEN WITHIN
C   ONE LARGE EVOLUTIONARY TIMESTEP.
         DO 1040 IM = 1,M
            DELRO(IM) = SDEL(1,IM)
            DELO(IM) = SDEL(2,IM)
            DELAO(IM) = SDEL(3,IM)
            AMUO(IM) = HAMU(IM)
            OO(IM) = SO(IM)
            CPO(IM) = CP(IM)
            QDTO(IM) = SQDT(IM)
            VELO(IM) = SVEL(IM)
            VISCO(IM) = VISC(IM)
            THDIFO(IM) = THDIF(IM)
C MHP 06/02
            DDELM(IM) = DELAO(IM) - DELO(IM)
C MHP 6/00 CALCULATED EARLIER
C            ESUMO(IM) = SESUM(IM)
            QWRMX0(IM) = QWRMAX(IM)
 1040    CONTINUE
C MHP 06/02 ADDED TERM FOR THE TIME EVOLUTION
C OF THE ANGULAR VELOCITY DISTRIBUTION
         DO I = 2,M
            DR = EXP(CLN*HR(I))-EXP(CLN*HR(I-1))
            DW = OMEGA(I) - OMEGA(I-1)
            WMID = 0.5D0*(OMEGA(I)+OMEGA(I-1))
            FAC = 2.0D0*(HR(I)+HR(I-1))-0.5D0*
     *            (HS(I)+HS(I-1))-CGL
            THO(I) = EXP(CLN*FAC)*WMID*DW/DR
            QWRST(I) = DW/DR
         END DO
      ENDIF
C  CALCULATE NEW SURFACE OPACITY TABLE IF NEEDED.
      IF(DABS(XNEW-HCOMP(1,M)).GT.1.0D-8) THEN
               XNEW = HCOMP(1,M)
               ZNEW = HCOMP(3,M)
               CALL SURFOPAC(XNEW)

      END IF

      RETURN
      END
